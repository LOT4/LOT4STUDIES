<<<<<<< Updated upstream
source(paste0(pre_dir,"functions/", "FUNCTIONS.R"))
#Set parameters
source(paste0(pre_dir,"Step_00_SetParameters.R"))
#Preparation of analyses input tables
source(paste0(pre_dir,"Step_01_CreateSpells.R"))
source(paste0(pre_dir,"Step_02_PreparePersonsTable.R"))
source(paste0(pre_dir,"DeleteThisPart.R"))
source(paste0(pre_dir, "Step_03_CreateSourceTable.R"))
source(paste0(pre_dir,"Step_04_CreateStudyPopulation.R"))
#
source(paste0(pre_dir,"Step_05_AddVariablesSourcePopulation.R"))
source(paste0(pre_dir,"Step_06_AddVariablesStudyPopulation.R"))
source(paste0(pre_dir,"Step_07_RunCountPersonTime.R"))
source(paste0(pre_dir,"functions/", "CountPersonTimeV13.3.R"))
source(paste0(pre_dir,"Step_07_RunCountPersonTime.R"))
#Save analyses output tables in output
source(paste0(pre_dir,"Step_Report_01_01_PopulationTree.R"))
source(paste0(pre_dir,"Step_Report_01_02_CompareStudySource.R"))
source(paste0(pre_dir,"Step_Report_01_03_Persontime.R"))
source(paste0(pre_dir,"Step_Report_01_0405_CountPersontime.R"))
source(paste0(pre_dir,"Step_Report_01_0609_AnalyseDates.R"))
if(SUBP) SCHEME_01_0609 <- subpopulation_meanings[,
':='
(
file_in = paste0(subpopulations,"_study_population.rds"),
file_out = paste0(subpopulations,"_R_01_0608_DT"),
file_out2 = paste0(subpopulations,"_R_01_09_DT_birth_date_day.csv"),
folder_in = populations_dir,
folder_out = std_source_pop_dir)
]
STUDY_POPULATION <- readRDS(file = paste0(SCHEME_01_0609[["folder_in"]][i],SCHEME_01_0609[["file_in"]][i]))[sex_at_instance_creation %in% c("F","M"),]
for(j in Analyse_dates){
TEMP <- STUDY_POPULATION[,.(count = sum(!is.na(person_id))), keyby = c(paste0(j,"_month"),paste0(j,"_year"))]
if(j == "birth_date") {
TEMP <- dcast(TEMP, get(paste0(j,"_year")) ~ get(paste0(j,"_month")), value.var = "count")
}
if(j != "birth_date") {
TEMP2 <- INPUTMATRIX(
d = TEMP,
value = "count",
type = "none",
var = paste0(j,"_month"),
var.v = c(1:12),
cat = paste0(j,"_year"),
cat.v = c(min(TEMP[[paste0(j,"_year")]]):max(TEMP[[paste0(j,"_year")]])),
per = F
)
saveRDS(TEMP2, file = paste0(SCHEME_01_0609[["folder_out"]][i],SCHEME_01_0609[["file_out"]][i],"_",j,"_PLOT.rds"))
TEMP <- dcast(TEMP, get(paste0(j,"_month")) ~ get(paste0(j,"_year")), value.var = "count")
}
TEMP[is.na(TEMP)] <- 0
if(j == "birth_date") setnames(TEMP,"j","year")
if(j != "birth_date") setnames(TEMP,"j","month")
fwrite(TEMP, file = paste0(SCHEME_01_0609[["folder_out"]][i],SCHEME_01_0609[["file_out"]][i],"_",j,".csv"), sep = ";")
rm(TEMP)
gc()
}
TEMP <- STUDY_POPULATION[,.(count = sum(!is.na(person_id))), keyby = c(paste0(j,"_month"),paste0(j,"_year"))]
if(j == "birth_date") {
TEMP <- dcast(TEMP, get(paste0(j,"_year")) ~ get(paste0(j,"_month")), value.var = "count")
}
if(j != "birth_date") {
TEMP2 <- INPUTMATRIX(
d = TEMP,
value = "count",
type = "none",
var = paste0(j,"_month"),
var.v = c(1:12),
cat = paste0(j,"_year"),
cat.v = c(min(TEMP[[paste0(j,"_year")]]):max(TEMP[[paste0(j,"_year")]])),
per = F
)
saveRDS(TEMP2, file = paste0(SCHEME_01_0609[["folder_out"]][i],SCHEME_01_0609[["file_out"]][i],"_",j,"_PLOT.rds"))
TEMP <- dcast(TEMP, get(paste0(j,"_month")) ~ get(paste0(j,"_year")), value.var = "count")
}
STUDY_POPULATION <- readRDS(file = paste0(SCHEME_01_0609[["folder_in"]][i],SCHEME_01_0609[["file_in"]][i]))[sex_at_instance_creation %in% c("F","M"),]
View(SCHEME_01_0609)
rm(list=ls())
if(!require(rstudioapi)){install.packages("rstudioapi")}
library(rstudioapi)
projectFolder<-dirname(rstudioapi::getSourceEditorContext()$path)
setwd(projectFolder)
###################################################
#Parameters
#################################################
#females age
min_age_preg<-12
max_age_preg<-55
#Set parameters basic parameters
start_study_date <- "20150101"
end_study_date <- "20181231"
lookback_period <- 365
Age_max <- 0
Age_min <- 56
######################################################################################################
#Specify all meanings that refer to birth registry in the SURVEY_ID table(if applicable) for identifying pregnancy
#example meanings_birth_registry<-c("birth_registry", "birth_registry_meanings")
#keep in mind this records will be classified as end_of_pregnancy so no spontaneous abortion registry should be included
meanings_birth_registry<-c("birth_registry_mother")
#######################################################################################################
source("packages.R")
source("99_path.R")
source(paste0(pre_dir, "info.R"))
setwd(projectFolder)
#################################################
################################################################
########################################################
#Create output folders
########################################################
if (subpopulations_present=="No"){
#output folder for STUDY_SOURCE_POPULATION report in g_output
if ("STUDY_SOURCE_POPULATION" %in% list.files(output_dir)){
unlink(paste0(output_dir,"STUDY_SOURCE_POPULATION"), recursive = T)#delete folder
dir.create(paste(output_dir, "STUDY_SOURCE_POPULATION", sep=""))
std_source_pop_dir<-paste(output_dir, "STUDY_SOURCE_POPULATION/", sep="")
dir.create(paste(std_source_pop_dir,"Masked", sep=""))
} else {
#Create the  folder in the output dir
dir.create(paste(output_dir, "STUDY_SOURCE_POPULATION", sep=""))
std_source_pop_dir<-paste(output_dir, "STUDY_SOURCE_POPULATION/", sep="")
dir.create(paste(std_source_pop_dir,"Masked", sep=""))
}
#STUDY_SOURCE_POPULATION_tmp/STUDY_SOURCE_POPULATION folder where all intermediary files are saved
if ("STUDY_SOURCE_POPULATION" %in% list.files(tmp)){
unlink(paste0(tmp,"STUDY_SOURCE_POPULATION"), recursive = T)#delete folder
dir.create(paste(tmp, "STUDY_SOURCE_POPULATION", sep=""))
std_pop_tmp<-paste(tmp, "STUDY_SOURCE_POPULATION/", sep="")
}else{
#Create the STUDY_SOURCE_POPULATION folder in the output dir
dir.create(paste(tmp, "STUDY_SOURCE_POPULATION", sep=""))
std_pop_tmp<-paste(tmp, "STUDY_SOURCE_POPULATION/", sep="")
}
} else {
#output folder for MEDICINES report in g_output
if ("STUDY_SOURCE_POPULATION" %in% list.files(output_dir)){
unlink(paste0(output_dir,"STUDY_SOURCE_POPULATION"), recursive = T)#delete folder
dir.create(paste(output_dir, "STUDY_SOURCE_POPULATION", sep=""))
std_source_pop_dir<-paste(output_dir, "STUDY_SOURCE_POPULATION/", sep="")
do.call(file.remove, list(list.files(std_source_pop_dir, full.names = T)))
for (i in 1:length(subpopulations_names)){
dir.create(paste0(std_source_pop_dir, subpopulations_names[i]))
}
for (i in 1:length(subpopulations_names)){
dir.create(paste0(std_source_pop_dir, subpopulations_names[i],"/Masked"))
}
} else {
#Create the STUDY_SOURCE_POPULATION folder in the output dir
dir.create(paste(output_dir, "STUDY_SOURCE_POPULATION", sep=""))
std_source_pop_dir<-paste(output_dir, "STUDY_SOURCE_POPULATION/", sep="")
for (i in 1:length(subpopulations_names)){
dir.create(paste0(std_source_pop_dir, subpopulations_names[i]))
}
for (i in 1:length(subpopulations_names)){
dir.create(paste0(std_source_pop_dir, subpopulations_names[i],"/Masked"))
}
}
#STUDY_SOURCE_POPULATION_tmp/STUDY_SOURCE_POPULATION folder where all intermediary files are saved
if ("STUDY_SOURCE_POPULATION" %in% list.files(tmp)){
unlink(paste0(tmp,"STUDY_SOURCE_POPULATION"), recursive = T)#delete folder
dir.create(paste(tmp, "STUDY_SOURCE_POPULATION", sep=""))
std_pop_tmp<-paste(tmp, "STUDY_SOURCE_POPULATION/", sep="")
}else{
#Create the STUDY_SOURCE_POPULATION folder in the output dir
dir.create(paste(tmp, "STUDY_SOURCE_POPULATION", sep=""))
std_pop_tmp<-paste(tmp, "STUDY_SOURCE_POPULATION/", sep="")
}
}
#######################################################
#std_source_pop_dir output folder for study_source population
#std_pop_tmp output folder for temporary files
#############################################################
#Load functions
source(paste0(pre_dir,"functions/", "CreateSpells_v_10.R"))
source(paste0(pre_dir,"functions/", "CountPersonTimeV12.5.R"))
source(paste0(pre_dir,"functions/", "CountPersonTimeV13.3.R"))
source(paste0(pre_dir,"functions/", "FUNCTIONS.R"))
#Set parameters
source(paste0(pre_dir,"Step_00_SetParameters.R"))
#Preparation of analyses input tables
source(paste0(pre_dir,"Step_01_CreateSpells.R"))
PC_OBS_SPELLS <- readRDS("C:/Level-3-checks/Data characterisation/Level_3_to_be_deployed/g_intermediate/tmp/STUDY_SOURCE_POPULATION/PC_OBS_SPELLS.rds")
source(paste0(pre_dir,"Step_02_PreparePersonsTable.R"))
source(paste0(pre_dir,"DeleteThisPart.R"))
source(paste0(pre_dir, "Step_03_CreateSourceTable.R"))
PC_source_population <- readRDS("C:/Level-3-checks/Data characterisation/Level_3_to_be_deployed/g_intermediate/tmp/STUDY_SOURCE_POPULATION/PC_source_population.rds")
source(paste0(pre_dir,"Step_04_CreateStudyPopulation.R"))
PC_study_population <- readRDS("C:/Level-3-checks/Data characterisation/Level_3_to_be_deployed/g_intermediate/populations/PC_study_population.rds")
rm(list=ls())
if(!require(rstudioapi)){install.packages("rstudioapi")}
library(rstudioapi)
projectFolder<-dirname(rstudioapi::getSourceEditorContext()$path)
setwd(projectFolder)
###################################################
#Parameters
#################################################
#females age
min_age_preg<-12
max_age_preg<-55
#Set parameters basic parameters
start_study_date <- "19950101"
end_study_date <- "20181231"
lookback_period <- 365
Age_max <- 0
Age_min <- 56
######################################################################################################
#Specify all meanings that refer to birth registry in the SURVEY_ID table(if applicable) for identifying pregnancy
#example meanings_birth_registry<-c("birth_registry", "birth_registry_meanings")
#keep in mind this records will be classified as end_of_pregnancy so no spontaneous abortion registry should be included
meanings_birth_registry<-c("birth_registry_mother")
#######################################################################################################
source("packages.R")
source("99_path.R")
source(paste0(pre_dir, "info.R"))
setwd(projectFolder)
#################################################
#Study_source_population
#################################################
system.time(source(paste0(pre_dir,"study_source_population_script.R")))
#Create report
for(i in readRDS(paste0(std_pop_tmp,"SCHEME_06.rds"))[["subpopulations"]]){
rmarkdown::render(paste0(pre_dir,"Report_01_StudyPopulation.rmd"),
output_file = paste0(std_source_pop_dir,"Report_01_Study_population",i,".html"),
output_dir = std_source_pop_dir
)
}
####################################################
#Medicine exposure
####################################################
Rmd_MEDICINES<-paste0(pre_dir,"/MEDICINES_L3.Rmd")
source(paste0(pre_dir,"MEDICINES_L3.R"))
if(length(actual_tables$MEDICINES)>0){
if(subpopulations_present=="No"){
system.time(render(Rmd_MEDICINES, output_dir = paste0(output_dir,"MEDICINES/"), output_file = "MEDICINES_L3.html"))
} else {
for (a in 1: length(subpopulations_names)){
system.time(render(Rmd_MEDICINES, output_dir = paste0(output_dir,"MEDICINES/"), output_file = paste0(subpopulations_names[a],"_MEDICINES_L3.html")))
}
}
}
##################################################
#Vaccine exposure
##################################################
Rmd_VACCINES<-paste0(pre_dir,"/VACCINES_L3.Rmd")
source(paste0(pre_dir,"VACCINES_L3.R"))
if(length(actual_tables$VACCINES)>0){
if(subpopulations_present=="No"){
system.time(render(Rmd_VACCINES, output_dir = paste0(output_dir,"VACCINES/"), output_file = "VACCINES_L3.html"))
} else {
for (a in 1: length(subpopulations_names)){
system.time(render(Rmd_VACCINES, output_dir = paste0(output_dir,"VACCINES/"), output_file = paste0(subpopulations_names[a],"_VACCINES_L3.html")))
}
}
}
#################################################
#Diagnoses
#################################################
Rmd_DIAGNOSES<-paste0(pre_dir,"/DIAGNOSES_L3.Rmd")
source(paste0(pre_dir,"DIAGNOSES_L3.R"))
if(sum(length(actual_tables$EVENTS),length(actual_tables$MEDICAL_OBSERVATIONS),length(actual_tables$SURVEY_OBSERVATIONS))>0){
if(subpopulations_present=="No"){
system.time(render(Rmd_DIAGNOSES, output_dir = paste0(output_dir,"DIAGNOSES/"), output_file = "DIAGNOSES_L3.html"))
} else {
for (a in 1: length(subpopulations_names)){
system.time(render(Rmd_DIAGNOSES, output_dir = paste0(output_dir,"DIAGNOSES/"), output_file = paste0(subpopulations_names[a],"_DIAGNOSES_L3.html")))
}
}
}
#################################################
#Pregnancy
#################################################
Rmd_PREGNANCY<-paste0(pre_dir,"/PREGNANCY_L3.Rmd")
source(paste0(pre_dir,"PREGNANCY_L3.R"))
if(sum(length(actual_tables$EVENTS),length(actual_tables$MEDICAL_OBSERVATIONS),length(actual_tables$SURVEY_OBSERVATIONS), length(actual_tables$SURVEY_ID))>0){
if(subpopulations_present=="No"){
system.time(render(Rmd_PREGNANCY, output_dir = paste0(output_dir,"PREGNANCY/"), output_file = "PREGNANCY_L3.html"))
} else {
for (a in 1: length(subpopulations_names)){
system.time(render(Rmd_PREGNANCY, output_dir = paste0(output_dir,"PREGNANCY/"), output_file = paste0(subpopulations_names[a],"_PREGNANCY_L3.html")))
}
}
}
#################################################
#Populations of interest
#################################################
Rmd_POI<-paste0(pre_dir,"/POI_L3.Rmd")
source(paste0(pre_dir,"POI_L3.R"))
if(subpopulations_present=="No"){
system.time(render(Rmd_POI, output_dir = paste0(output_dir,"POI/"), output_file = "POI_L3.html"))
} else {
for (a in 1: length(subpopulations_names)){
system.time(render(Rmd_POI, output_dir = paste0(output_dir,"POI/"), output_file = paste0(subpopulations_names[a],"_POI_L3.html")))
}
}
rm(list=ls())
if(!require(rstudioapi)){install.packages("rstudioapi")}
library(rstudioapi)
projectFolder<-dirname(rstudioapi::getSourceEditorContext()$path)
setwd(projectFolder)
###################################################
#Parameters
#################################################
#females age
min_age_preg<-12
max_age_preg<-55
#Set parameters basic parameters
start_study_date <- "19950101"
end_study_date <- "20181231"
lookback_period <- 365
Age_max <- 0
Age_min <- 56
######################################################################################################
#Specify all meanings that refer to birth registry in the SURVEY_ID table(if applicable) for identifying pregnancy
#example meanings_birth_registry<-c("birth_registry", "birth_registry_meanings")
#keep in mind this records will be classified as end_of_pregnancy so no spontaneous abortion registry should be included
meanings_birth_registry<-c("birth_registry_mother")
#######################################################################################################
source("packages.R")
source("99_path.R")
source(paste0(pre_dir, "info.R"))
setwd(projectFolder)
#################################################
#Study_source_population
#################################################
system.time(source(paste0(pre_dir,"study_source_population_script.R")))
rm(list=ls())
if(!require(rstudioapi)){install.packages("rstudioapi")}
library(rstudioapi)
projectFolder<-dirname(rstudioapi::getSourceEditorContext()$path)
setwd(projectFolder)
###################################################
#Parameters
#################################################
#females age
min_age_preg<-12
max_age_preg<-55
#Set parameters basic parameters
start_study_date <- "19950101"
end_study_date <- "20181231"
lookback_period <- 365
Age_max <- 0
Age_min <- 56
######################################################################################################
#Specify all meanings that refer to birth registry in the SURVEY_ID table(if applicable) for identifying pregnancy
#example meanings_birth_registry<-c("birth_registry", "birth_registry_meanings")
#keep in mind this records will be classified as end_of_pregnancy so no spontaneous abortion registry should be included
meanings_birth_registry<-c("birth_registry_mother")
#######################################################################################################
source("packages.R")
source("99_path.R")
source(paste0(pre_dir, "info.R"))
setwd(projectFolder)
#################################################################
#Study_population and Source_population
################################################################
########################################################
#Create output folders
########################################################
if (subpopulations_present=="No"){
#output folder for STUDY_SOURCE_POPULATION report in g_output
if ("STUDY_SOURCE_POPULATION" %in% list.files(output_dir)){
unlink(paste0(output_dir,"STUDY_SOURCE_POPULATION"), recursive = T)#delete folder
dir.create(paste(output_dir, "STUDY_SOURCE_POPULATION", sep=""))
std_source_pop_dir<-paste(output_dir, "STUDY_SOURCE_POPULATION/", sep="")
dir.create(paste(std_source_pop_dir,"Masked", sep=""))
} else {
#Create the  folder in the output dir
dir.create(paste(output_dir, "STUDY_SOURCE_POPULATION", sep=""))
std_source_pop_dir<-paste(output_dir, "STUDY_SOURCE_POPULATION/", sep="")
dir.create(paste(std_source_pop_dir,"Masked", sep=""))
}
#STUDY_SOURCE_POPULATION_tmp/STUDY_SOURCE_POPULATION folder where all intermediary files are saved
if ("STUDY_SOURCE_POPULATION" %in% list.files(tmp)){
unlink(paste0(tmp,"STUDY_SOURCE_POPULATION"), recursive = T)#delete folder
dir.create(paste(tmp, "STUDY_SOURCE_POPULATION", sep=""))
std_pop_tmp<-paste(tmp, "STUDY_SOURCE_POPULATION/", sep="")
}else{
#Create the STUDY_SOURCE_POPULATION folder in the output dir
dir.create(paste(tmp, "STUDY_SOURCE_POPULATION", sep=""))
std_pop_tmp<-paste(tmp, "STUDY_SOURCE_POPULATION/", sep="")
}
} else {
#output folder for MEDICINES report in g_output
if ("STUDY_SOURCE_POPULATION" %in% list.files(output_dir)){
unlink(paste0(output_dir,"STUDY_SOURCE_POPULATION"), recursive = T)#delete folder
dir.create(paste(output_dir, "STUDY_SOURCE_POPULATION", sep=""))
std_source_pop_dir<-paste(output_dir, "STUDY_SOURCE_POPULATION/", sep="")
do.call(file.remove, list(list.files(std_source_pop_dir, full.names = T)))
for (i in 1:length(subpopulations_names)){
dir.create(paste0(std_source_pop_dir, subpopulations_names[i]))
}
for (i in 1:length(subpopulations_names)){
dir.create(paste0(std_source_pop_dir, subpopulations_names[i],"/Masked"))
}
} else {
#Create the STUDY_SOURCE_POPULATION folder in the output dir
dir.create(paste(output_dir, "STUDY_SOURCE_POPULATION", sep=""))
std_source_pop_dir<-paste(output_dir, "STUDY_SOURCE_POPULATION/", sep="")
for (i in 1:length(subpopulations_names)){
dir.create(paste0(std_source_pop_dir, subpopulations_names[i]))
}
for (i in 1:length(subpopulations_names)){
dir.create(paste0(std_source_pop_dir, subpopulations_names[i],"/Masked"))
}
}
#STUDY_SOURCE_POPULATION_tmp/STUDY_SOURCE_POPULATION folder where all intermediary files are saved
if ("STUDY_SOURCE_POPULATION" %in% list.files(tmp)){
unlink(paste0(tmp,"STUDY_SOURCE_POPULATION"), recursive = T)#delete folder
dir.create(paste(tmp, "STUDY_SOURCE_POPULATION", sep=""))
std_pop_tmp<-paste(tmp, "STUDY_SOURCE_POPULATION/", sep="")
}else{
#Create the STUDY_SOURCE_POPULATION folder in the output dir
dir.create(paste(tmp, "STUDY_SOURCE_POPULATION", sep=""))
std_pop_tmp<-paste(tmp, "STUDY_SOURCE_POPULATION/", sep="")
}
}
#######################################################
#std_source_pop_dir output folder for study_source population
#std_pop_tmp output folder for temporary files
#############################################################
#Load functions
source(paste0(pre_dir,"functions/", "CreateSpells_v_10.R"))
source(paste0(pre_dir,"functions/", "CountPersonTimeV12.5.R"))
source(paste0(pre_dir,"functions/", "CountPersonTimeV13.3.R"))
source(paste0(pre_dir,"functions/", "FUNCTIONS.R"))
#Set parameters
source(paste0(pre_dir,"Step_00_SetParameters.R"))
#Preparation of analyses input tables
source(paste0(pre_dir,"Step_01_CreateSpells.R"))
source(paste0(pre_dir,"Step_02_PreparePersonsTable.R"))
source(paste0(pre_dir,"DeleteThisPart.R"))
source(paste0(pre_dir, "Step_03_CreateSourceTable.R"))
source(paste0(pre_dir,"Step_04_CreateStudyPopulation.R"))
PC_study_population <- readRDS("C:/Level-3-checks/Data characterisation/Level_3_to_be_deployed/g_intermediate/populations/PC_study_population.rds")
View(PC_study_population)
if(SUBP){
SCHEME_04 <- copy(subpopulation_meanings)
SCHEME_04 <- SCHEME_04[, ':=' (file_in = paste0(subpopulations,"_source_population.rds"), file_out = paste0(subpopulations,"_study_population.rds"), folder_out = "populations") ]
}
View(SCHEME_04)
SCHEME_04$nrows <- as.integer(NA)
SCHEME_04$ncols <- as.integer(NA)
SCHEME_04$ncolsneeded <- 23
FlowChartSourcetoStudy <- list()
i=1
SOURCE <- readRDS(paste0(std_pop_tmp, SCHEME_04[["file_in"]][i]))
print('Exclude patients according to SelectionCriteria specified in to_run file')
for (j in 1:length(SelectionCriteria)){
before <- nrow(SOURCE)
SOURCE <- SOURCE[eval(SelectionCriteria[[j]]),]
after <- nrow(SOURCE)
FlowChartSourcetoStudy[[paste0(names(SelectionCriteria[j]),"_",SCHEME_04[["subpopulations"]][i])]]$step <- "04_CreateStudyPopulation"
FlowChartSourcetoStudy[[paste0(names(SelectionCriteria[j]),"_",SCHEME_04[["subpopulations"]][i])]]$population <- SCHEME_04[["subpopulations"]][i]
FlowChartSourcetoStudy[[paste0(names(SelectionCriteria[j]),"_",SCHEME_04[["subpopulations"]][i])]]$before <- before
FlowChartSourcetoStudy[[paste0(names(SelectionCriteria[j]),"_",SCHEME_04[["subpopulations"]][i])]]$after <- after
rm(before,after)
gc()
}
SOURCE <- readRDS(paste0(std_pop_tmp, SCHEME_04[["file_in"]][i]))
print('Exclude patients according to SelectionCriteria specified in to_run file')
length(SelectionCriteria)
SOURCE <- readRDS(paste0(std_pop_tmp, SCHEME_04[["file_in"]][i]))
print('Exclude patients according to SelectionCriteria specified in to_run file')
for (j in 1:length(SelectionCriteria)){
before <- nrow(SOURCE)
SOURCE <- SOURCE[eval(SelectionCriteria[[j]]),]
after <- nrow(SOURCE)
FlowChartSourcetoStudy[[paste0(names(SelectionCriteria[j]),"_",SCHEME_04[["subpopulations"]][i])]]$step <- "04_CreateStudyPopulation"
FlowChartSourcetoStudy[[paste0(names(SelectionCriteria[j]),"_",SCHEME_04[["subpopulations"]][i])]]$population <- SCHEME_04[["subpopulations"]][i]
FlowChartSourcetoStudy[[paste0(names(SelectionCriteria[j]),"_",SCHEME_04[["subpopulations"]][i])]]$before <- before
FlowChartSourcetoStudy[[paste0(names(SelectionCriteria[j]),"_",SCHEME_04[["subpopulations"]][i])]]$after <- after
rm(before,after)
gc()
}
View(FlowChartSourcetoStudy)
rm(list=ls())
if(!require(rstudioapi)){install.packages("rstudioapi")}
library(rstudioapi)
projectFolder<-dirname(rstudioapi::getSourceEditorContext()$path)
setwd(projectFolder)
###################################################
#Parameters
#################################################
#females age
min_age_preg<-12
max_age_preg<-55
#Set parameters basic parameters
start_study_date <- "19950101"
end_study_date <- "20181231"
lookback_period <- 365
Age_max <- 56
Age_min <- 0
######################################################################################################
#Specify all meanings that refer to birth registry in the SURVEY_ID table(if applicable) for identifying pregnancy
#example meanings_birth_registry<-c("birth_registry", "birth_registry_meanings")
#keep in mind this records will be classified as end_of_pregnancy so no spontaneous abortion registry should be included
meanings_birth_registry<-c("birth_registry_mother")
#######################################################################################################
source("packages.R")
source("99_path.R")
source(paste0(pre_dir, "info.R"))
setwd(projectFolder)
#################################################
#Study_source_population
#################################################
system.time(source(paste0(pre_dir,"study_source_population_script.R")))
#Create report
for(i in readRDS(paste0(std_pop_tmp,"SCHEME_06.rds"))[["subpopulations"]]){
rmarkdown::render(paste0(pre_dir,"Report_01_StudyPopulation.rmd"),
output_file = paste0(std_source_pop_dir,"Report_01_Study_population",i,".html"),
output_dir = std_source_pop_dir
)
}
=======
#
################################################################################################################################
end_date_new <- as.Date(ifelse(End_study_time <= Sys.Date(), Sys.Date(), End_study_time + 1),origin = "1970-01-01")
################################################################################################################################
#check if study start and stop dates are valid
################################################################################################################################
if(print) print("Check if Start_study_time and End_study_time are valid")
if(!sum(Start_study_time==seq.Date(as.Date("19000101","%Y%m%d"),Sys.Date(),by = Increment))==1){
if(Increment == "year"){stop("Change the start date to the first of january. Wrong study start date can produce invalid results.")}
if(Increment == "month"){stop("Change the start date to the first of month. Wrong study start date can produce invalid results.")}
if(Increment == "week"){stop("Change the start date to a monday. Wrong study start date can produce invalid results.")}
}
if(!sum(End_study_time==seq.Date(as.Date("19000101","%Y%m%d"),end_date_new ,by = Increment)-1)==1){
if(Increment == "year"){stop("Change the end date to the 31th of december. Wrong study start date can produce invalid results.")}
if(Increment == "month"){stop("Change the end date to the last day of the month. Wrong study start date can produce invalid results.")}
if(Increment == "week"){stop("Change the end date to a sunday. Wrong study start date can produce invalid results.")}
}
gc()
################################################################################################################################
date_cols<-c(Start_date,End_date,Birth_date)
# Reduce memory size using integers
Dataset[, c(date_cols) := lapply(.SD, as.IDate), .SDcols = date_cols]
#Dataset[, c(Strata) := lapply(.SD, as.integer), .SDcols = Strata]
gc()
#Check if start, end and birth date are all filled. If end date is not filled it will be replaced by the and study date
################################################################################################################################
if(print) print("Check if date columns in input data are valid and in correct order")
if(sum(is.na(Dataset[,.(get(Start_date))]))>0){stop("Empty start dates")}
if(!is.null(Age_bands)){if(sum(is.na(Dataset[,.(get(Birth_date))]))>0){stop("Empty birth dates")}}
if(sum(is.na(Dataset[,.(get(End_date))]))>0){print(paste0(sum(is.na(Dataset[,.(get(End_date))]))," empty end dates will be filled with the end study date. This may cause overlapping intervals"))}
Dataset[is.na(get(End_date)),eval(End_date) := End_study_time]
gc()
#Check the order of dates
################################################################################################################################
wrong_End_date<-nrow(Dataset[get(Start_date)>get(End_date),])
if (wrong_End_date>0){warning(paste0(wrong_End_date," end date(s) prior to start date"))}
wrong_Start_date<-nrow(Dataset[get(Start_date)>Sys.Date(),])
if (wrong_Start_date>0){warning(paste0(wrong_Start_date," start date(s) in future"))}
if(!is.null(Age_bands)){
wrong_Birth_date<-nrow(Dataset[get(Start_date)<get(Birth_date),])
if (wrong_Birth_date>0){warning(paste0(wrong_Start_date," start date(s) before birth date"))}}
################################################################################################################################
#Check if birthdays are unique
################################################################################################################################
#if(!is.null(Age_bands)){
# if(nrow(Dataset[,uniqueN(get(Birth_date)), by = Person_id][V1>1,])!=0){stop("Persons with several birth dates") }
#}
################################################################################################################################
#Check if the subjects have overlap in the time intervals (within strata???), defined by end-start date.
################################################################################################################################
if(check_overlap){
if(print) print("Check if observation periods do not have overlap")
test_overlap<-Dataset[!is.na(get(End_date))&!is.na(get(End_date))&get(End_date)>get(Start_date),][,.(get(Person_id), as.integer(get(Start_date)), as.integer(get(End_date)))]
setkey(test_overlap,V1,V2,V3)
test_overlap2<-as.data.table(foverlaps(test_overlap, test_overlap, type="any", which=TRUE))
test_overlap2<-test_overlap2[xid!=yid,]
test_overlap[,id:=as.integer(rownames(test_overlap))]
overlap_subjects<-unlist(unique(test_overlap2[test_overlap, on = .(xid = id), nomatch=NULL][,.(V1)]))
if(length(overlap_subjects) > 0){
warning("Subjects have overlapping person time: ")
warning(paste0(overlap_subjects," "))
stop("Invalid results could be generated so the script is stopped")
}
rm(test_overlap,test_overlap2,overlap_subjects)
gc()
}
################################################################################################################################
#Select relevant data
################################################################################################################################
intv <- as.IDate(c(Start_study_time, End_study_time))
Dataset <- Dataset[get(Start_date) %between% intv|get(End_date) %between% intv|(get(Start_date) < Start_study_time & get(End_date) > End_study_time)]
if(nrow(Dataset) == 0){
Dataset <- NULL
if(print) print("No subjects with any observation time within studyperiod. NULL is returned")
}else{
Dataset[get(Start_date) < Start_study_time,eval(Start_date):=Start_study_time]
Dataset[get(End_date) > End_study_time,eval(End_date) := End_study_time]
start <- Start_study_time
end <- End_study_time
Time_Increment <- as.IDate(seq.Date(start, end, Increment))
################################################################################################################################
#Enlarge table by time increment. If agebands, then calculate tha ages at the start and at the end of every new created time interval
################################################################################################################################
if(print) print(paste0("Transform input date to a dataset per ", Increment, ". This step increases the size of the file with respect to the choosen increment" ))
Table_Temp <- copy(Dataset[0])
gc()
for(i in 1:length(Time_Increment)){
first_day <- Time_Increment[i]
last_day <- as.IDate(seq.Date(Time_Increment[i], by = Increment, length = 2) - 1)
last_day <- last_day[2]
Temp <- copy(Dataset)
Temp[,eval(Increment) := Time_Increment[i]]
Temp <- Temp[!((get(Start_date) < first_day & get(End_date) < first_day) | (get(Start_date) > last_day & get(End_date) > last_day)),]
Temp[get(Start_date) <= first_day & get(End_date) >= first_day,eval(Start_date) := first_day ]
Temp[get(End_date) >= last_day & get(Start_date) <= last_day, eval(End_date) := last_day]
gc()
Table_Temp <- rbindlist(list(Table_Temp, Temp), fill = TRUE)
rm(Temp)
gc()
}
rm(Dataset)
gc()
Dataset <- Table_Temp
rm(Table_Temp)
gc()
################################################################################################################################
#Determine the ages at the beginning and end of all observation periods. Output is a starting point for calculation and splitting of
# age bands
################################################################################################################################
if(!is.null(Age_bands)){
if(print) print(paste0("Calculate ages at the start and end of every observation period by ", Increment))
if (nrow(Dataset) > 0){
Dataset[, age_start := floor(time_length(interval(get(Birth_date), get(Start_date)), Unit_of_age)) ]
Dataset[, age_end := floor(time_length(interval(get(Birth_date), get(End_date)), Unit_of_age)) ]
} else{
Dataset[,age_start := NA]
Dataset[,age_end := NA]
}
}
################################################################################################################################
#Calculate agebands in 2 steps ((1)split/recalculate start/end ages and (assign row to ageband) )
################################################################################################################################
if(!is.null(Age_bands)){
#Split time interval that are switching from ageband. Those rows are doubled and start end end dates are changed
if(Increment != "day" ){for(j in Age_bands){
if(print) print(paste0("Spliting rows that fall within several agebands for age ", j))
if(j!= 0){
if(j == Age_bands[1]){j <- j-1}
temp <- as.data.table(Dataset[age_end>j & age_start <= j,])
if(nrow(temp) > 0){
temp[age_end > j & age_start <= j,change_date := as.IDate(add_with_rollback(get(Birth_date), period(j+1,units = Unit_of_age), roll_to_first = T, preserve_hms = T))]
Dataset[age_end > j & age_start <= j,change_date := as.IDate(add_with_rollback(get(Birth_date), period(j+1,units = Unit_of_age), roll_to_first = T, preserve_hms = T))]
Dataset[change_date > get(Start_date) & age_end > j & age_start <= j, eval(End_date) := as.IDate(change_date-1)]
temp[change_date <= get(End_date),eval(Start_date) := as.IDate(change_date)]
#Dataset<-rbind(Dataset,temp)
Dataset <- rbindlist(list(Dataset,temp), fill = TRUE)
}
rm(temp)
gc()
#Recalculate start end end age for rows that are doubled
Dataset[age_end > j & age_start <= j, ':=' (
age_start = floor(time_length(interval(get(Birth_date), get(Start_date)), Unit_of_age)),
age_end = floor(time_length(interval(get(Birth_date), get(End_date)), Unit_of_age))
)]
gc()
}
}}
#assign age bands
if(print) print("Assign agebands")
for (k in 1:length(Age_bands)){
#if (k==1){Dataset[age_start %between% c(0,Age_bands[k]) & age_end %between% c(0,Age_bands[k]),Ageband := paste0("0-",Age_bands[k])]}
if (k == 1){Dataset <- Dataset[age_end >= Age_bands[k],]}
if (k == 2){Dataset[age_start %between% c(Age_bands[k-1],Age_bands[k]) & age_end %between% c(Age_bands[k-1],Age_bands[k]),Ageband := paste0(Age_bands[k-1],"-",Age_bands[k])]}
if (k > 2 & k < length(Age_bands)+1){Dataset[age_start %between% c(Age_bands[k-1]+1,Age_bands[k]) & age_end %between% c(Age_bands[k-1]+1,Age_bands[k]),Ageband := paste0(Age_bands[k-1]+1,"-",Age_bands[k])]}
if (k == length(Age_bands) & include_remaning_ages == T){Dataset[age_start >= Age_bands[k]+1,Ageband := paste0(Age_bands[k]+1,"+")]}
if (k == length(Age_bands) & include_remaning_ages == F){Dataset <- Dataset[age_start <= Age_bands[k],]}
}
Age_band_coln<-"Ageband"
} else Age_band_coln<-"Ageband"<-NULL
#NEW CODE V11 If recurrent events is true. This is a whole different approach compared to the situation where only the first
# event is used. When joining multiple doubling will occur. I choose to do not do this and choose a method only allowing joins
# that have unique combinations
################################################################################################################################
#Combine two input datasets to one dataset if only the first occurrence of an event is evaluated or exclude events that are following
#the previous event within a time period.
################################################################################################################################
if (!is.null(Dataset_events)) {
Dataset_events <- copy(Dataset_events)
#NEW CODE FROM V11
if(nrow(Dataset_events) > 0){
Dataset_events <- Dataset_events[get(Name_event) %in% Outcomes,]
# set date to integer to spare RAM
Dataset_events[, c(Date_event) := lapply(.SD, as.IDate), .SDcols = Date_event]
colls_outcomes <- Outcomes[Outcomes %in% Dataset_events[,get(Name_event)]]
setorderv(Dataset_events,c(Person_id,Name_event,Date_event))
Dataset_events[,Recurrent := cumsum(!is.na(get(Date_event))),by=c(Person_id,Name_event)]
if(Rec_events){
if(print) print("If Rec_events = T then determine the censoring periods")
it=1
if(!length(Rec_period)==length(Outcomes)) stop("the vectors Outcomes and rec period have different lengths")
#events_rec_list <- list()
events_rec_list <- copy(Dataset_events[0])
for (i in 1:length(Outcomes)){
events_rec  <- copy(Dataset_events)[get(Name_event) == Outcomes[i],]
while(nrow(events_rec) > 0){
events_rec <- events_rec[,D := shift(get(Date_event)),by = c(Person_id,Name_event) ]
events_rec[,dif := get(Date_event)-D]
events_rec[is.na(dif), dif := 0 ][,dif := as.numeric(dif)]
events_rec[,cumdif := cumsum(dif),by = c(Person_id,Name_event)]
events_rec_list <- rbindlist(list(events_rec_list,events_rec[ cumdif <= Rec_period[i],][,.SD[1], c(Person_id,Name_event)][,Iteration := it]),fill=T)
#events_rec_list[[it]] <- events_rec[ cumdif <= Rec_period[i],][,.SD[1], c(Person_id,Name_event)][,Iteration := it]
events_rec <- events_rec[cumdif > Rec_period[i],]
lapply(c("dif","cumdif","D"), function(x){events_rec <-events_rec[,eval(x) := NULL]})
it=it+1
gc()
}
rm(events_rec)
gc()
}
#Dataset_events <- do.call(rbind,events_rec_list)
Dataset_events <- events_rec_list
rm(events_rec_list)
gc()
for(i in 1:length(Rec_period)){
Dataset_events<- Dataset_events[dif!=0 & get(Name_event) == Outcomes[i] & dif < Rec_period[i],Delete:=T][is.na(Delete),]
Dataset_events <- Dataset_events[get(Name_event) == Outcomes[i], ":=" (RecSTDT=get(Date_event),RecENDT=get(Date_event)+Rec_period[i])]
gc()
}
lapply(c("dif","cumdif","D","Iteration"), function(x){Dataset_events <-Dataset_events[,eval(x) := NULL]})
Dataset_events<-dcast(Dataset_events, get(Person_id) + Recurrent ~ get(Name_event), value.var = c(Date_event,"RecSTDT","RecENDT"))
setcolorder(Dataset_events,neworder = c('Person_id','Recurrent',paste0(Date_event,"_",colls_outcomes),paste0("RecSTDT_",colls_outcomes),paste0("RecENDT_",colls_outcomes)))
colnames(Dataset_events) <- c('Person_id','Recurrent',colls_outcomes,paste0("RecSTDT_",colls_outcomes),paste0("RecENDT_",colls_outcomes))
} else {
if(print) print("If Rec_events = F then selecting only the first event")
Dataset_events <- Dataset_events[Recurrent==1,]
Dataset_events<-dcast(Dataset_events, get(Person_id) + Recurrent ~ get(Name_event), value.var = eval(Date_event))
setcolorder(Dataset_events,neworder = c('Person_id','Recurrent',colls_outcomes))
setkeyv(Dataset,Person_id)
setkey(Dataset_events,Person_id)
Dataset<-Dataset_events[Dataset,][,Recurrent := NULL]
setnames(Dataset, "Person_id", eval(Person_id))
}
invisible(lapply(Outcomes, function(x) if (!x %in% colnames(Dataset)) Dataset <- Dataset[, eval(x) := as.IDate(NA, format = "%d%m%Y")]))
} else{
invisible(lapply(Outcomes, function(x) Dataset <- Dataset[, eval(x) := as.IDate(NA, format = "%d%m%Y")]))
}
################################################################################################################################
if(Rec_events){
REC <- sort(unique(Dataset_events[,Recurrent]))
setnames(Dataset,eval(Person_id) ,"Person_id" )
p <- as.data.table(expand.grid(REC,colls_outcomes))
colnames(p) <-c("REC","OUTC")
check_combinations <- list()
for(i in colls_outcomes){
DT_temp <- copy(Dataset_events)
check_combinations[[i]] <- unique(DT_temp[,  ':=' (Event = i,sum = sum(!is.na(get(i)))),by = Recurrent ][,c("Event","sum","Recurrent")])
rm(DT_temp)
gc()
}
check_combinations <- do.call(rbind,check_combinations)
setkey(p,REC,OUTC)
setkey(check_combinations,Recurrent,Event)
p <- as.data.frame(p[check_combinations,][sum>0,])
Dataset[,row :=row.names(Dataset)]
#Calculate for every observation period the amount of persontime that needs to subtracted for every event
################################################################################################################################
for(i in 1:nrow(p)){
if(print) print(paste0("Calculate days to subtract from persontime for ",p[i,"OUTC"]," for recurrent event ",p[i,"REC"]))
ST<-paste0("RecSTDT_",p[i,"OUTC"])
EN<-paste0("RecENDT_",p[i,"OUTC"])
SUB<- paste0("SUBTRCUM_",p[i,"OUTC"])
Dataset<-copy(Dataset)
temp_events <- copy(Dataset_events)[Recurrent == p[i,"REC"],]
setkey(Dataset,Person_id)
setkey(temp_events,Person_id)
Dataset<-temp_events[Dataset,]
if(nrow(Dataset[ !((get(ST) < get(Start_date) & get(EN) < get(Start_date)) | (get(ST) > get(End_date) & get(EN) > get(End_date))),]) > 0){
Dataset <- Dataset[!((get(ST) < get(Start_date) & get(EN) < get(Start_date)) | (get(ST) > get(End_date) & get(EN) > get(End_date))) ,
':='
(start_date2 = max(get(Start_date),get(ST),na.rm=T),
end_date2 = min(get(End_date)+1,get(EN),na.rm=T)
),
by=row]
Dataset <- Dataset[,SUBTR := (as.numeric(end_date2)-as.numeric(start_date2)),by=row]
if(!any(colnames(Dataset)==SUB)) Dataset <- Dataset[,eval(SUB) := 0]
Dataset <- Dataset[!is.na(SUBTR),eval(SUB) := SUBTR+get(SUB)]
del <- c("SUBTR","start_date2","end_date2","Recurrent",colls_outcomes,paste0("RecSTDT_",colls_outcomes),paste0("RecENDT_",colls_outcomes))
lapply(del, function(x){Dataset <-Dataset[,eval(x) := NULL]})
} else {
del <- c("Recurrent",colls_outcomes,paste0("RecSTDT_",colls_outcomes),paste0("RecENDT_",colls_outcomes))
lapply(del, function(x){Dataset <- Dataset[,eval(x):=NULL]})
}
rm(ST,EN,SUB,temp_events,del)
gc()
}
#Check if all outcomes are present. If not add column with value 0
#if(length(Outcomes[!Outcomes %in% unique(p[["OUTC"]])]) > 0)lapply(paste0("SUBTRCUM_",Outcomes[!Outcomes %in% unique(p[["OUTC"]])]), function(x){Dataset <-Dataset[,eval(x) := 0]})
SUBTRCUM_MISSING <- Outcomes[!paste0("SUBTRCUM_",Outcomes) %in% unique(colnames(Dataset))]
if(length(SUBTRCUM_MISSING) > 0)lapply(paste0("SUBTRCUM_",SUBTRCUM_MISSING), function(x){Dataset <-Dataset[,eval(x) := 0]})
################################################################################################################################
#Calculate the number of events per observation period
################################################################################################################################
k <- c("Person_id",Start_date,End_date)
for(i in colls_outcomes){
if(print) print(paste0("Count the number of events per subject per ",Increment," for ", i))
Dataset_temp <- copy(Dataset)[,c("Person_id",Start_date,End_date),with=F]
Event_temp <- copy(Dataset_events)[!is.na(get(i)),c("Person_id",i),with=F]
setkey(Dataset_temp,Person_id)
setkey(Event_temp,Person_id)
#####Problem
#old
#Dataset_temp <- Dataset_temp[Event_temp,][between(get(i),get(Start_date),get(End_date),NAbounds = F),]
#new
Dataset_temp <- merge(x = Dataset_temp, y = Event_temp)[get(i) %between% list(get(Start_date),get(End_date)),]
#Could also use foverlaps, need to test this
#####Problem
Dataset_temp<-Dataset_temp[,paste0(i,"_b") := sum(!is.na(get(i))),by = c("Person_id",Start_date,End_date)]
Dataset_temp <- unique(Dataset_temp[,eval(i) := NULL])
setkeyv(Dataset_temp,k)
setkeyv(Dataset,k)
Dataset <- Dataset_temp[Dataset,][is.na(get(paste0(i, "_b"))), eval(paste0(i, "_b")) := 0]
rm(Event_temp,Dataset_temp)
gc()
}
#if(length(Outcomes[!Outcomes %in% unique(p[["OUTC"]])]) > 0)lapply(paste0(Outcomes[!Outcomes %in% unique(p[["OUTC"]])],"_b"), function(x){Dataset <-Dataset[,eval(x) := 0]})
B_MISSING <- Outcomes[!paste0(Outcomes, "_b") %in% unique(colnames(Dataset))]
if(length(B_MISSING) > 0)lapply(paste0(B_MISSING,"_b"), function(x){Dataset <-Dataset[,eval(x) := 0]})
################################################################################################################################
}
}
################################################################################################################################
# If aggregate is TRUE create columns for aggregation. I do this earlier in the program, so sparated from the aggregation so that I can delete Dataset_events earlier for
#RAM optimalistation
if (Aggregate == T) {
if (!is.null(Dataset_events)){
PT_colls <- c("Persontime",paste0("Persontime_",Outcomes),paste0(Outcomes,"_b"))
}else{
PT_colls <- "Persontime"
}
if (!is.null(Age_bands)){
by_colls <- c(Strata, Increment, "Ageband")
}else{
by_colls <- c(Strata, Increment)
}
}
################################################################################################################################
#Calculate persontimes
################################################################################################################################
if(print) print("Calculate persontimes")
if(!is.null(Dataset_events)){
rm(Dataset_events)
gc()
Outcomes_b <- paste0(Outcomes, "_b")
Persontime_Outcomes <- paste0("Persontime_", Outcomes)
#sort_order <- c(eval(Person_id), eval(Start_date))
sort_order <- c(eval(Person_id), eval(Start_date),Age_band_coln,eval(Strata))
coln <- c(eval(Person_id), eval(Strata), Age_band_coln, eval(Increment), "Persontime", eval(Persontime_Outcomes), eval(Outcomes_b))
Dataset[,Persontime := .(get(End_date)-get(Start_date) + 1)]
if(!Rec_events){
lapply(Outcomes,function(x)Dataset[,paste0(eval(x),"_b") := fifelse(!is.na(get(x)) & get(x) %between% list(get(Start_date),get(End_date)),1,0)])
lapply(Outcomes, function(x) Dataset[,paste0("Persontime_",x) := fifelse(!is.na(get(x)) & get(x) < get(Start_date), 0, Persontime)])
#lapply(Outcomes,function(x)Dataset[get(x) %between% list(get(Start_date),get(End_date)),`:=`(paste0(eval(x),"_b")= 1, paste0("Persontime_",x) = .(get(x)-get(Start_date)+1))])
lapply(Outcomes,function(x)Dataset[get(x) %between% list(get(Start_date),get(End_date)),paste0("Persontime_",x) := .(get(x)-get(Start_date)+1)])
}
if(Rec_events){
setnames(Dataset,"Person_id",eval(Person_id))
lapply(Outcomes,function(x)Dataset[,paste0("Persontime_",x) := .(get(End_date) - get(Start_date) + 1 - get(paste0("SUBTRCUM_",x)))])
}
} else {
#rm(Dataset_events)
#gc()
Dataset[,Persontime := .(get(End_date)-get(Start_date) + 1)]
sort_order <- c(eval(Person_id), eval(Start_date),Age_band_coln,eval(Strata))
coln <- c(eval(Person_id), eval(Strata), Age_band_coln, eval(Increment),"Persontime")
}
################################################################################################################################
#Create output table
################################################################################################################################
if(print) print("Create output table")
if(Increment=="month"){Dataset[,eval(Increment) := substr(get(Increment),1,7)]}
if(Increment=="year"){Dataset[,eval(Increment) := substr(get(Increment),1,4)]}
setorderv(Dataset, sort_order)
Dataset <- Dataset[,coln,with=FALSE]
#Aggregate based on PT_colls and by_colls created earlier
if (Aggregate == T) {
Dataset <- Dataset[, lapply(.SD, sum), .SDcols = PT_colls, by = by_colls]
rm(PT_colls,by_colls)
}
}
return(Dataset)
################################################################################################################################
rm(Dataset)
gc()
}
Output_file2<-CountPersonTime(
Dataset = medicines[!duplicated(person_id)],
Person_id = "person_id",
Start_study_time = "19900101",
End_study_time = "20211231",
Start_date = "start_follow_up",
End_date = "op_end_date",
Birth_date = "birth_date",
Increment="year",
Unit_of_age = "year",
include_remaning_ages = T,
Aggregate = T
)
View(Output_file2)
medicines<-lapply(paste0(medicines_pop, subpopulations_names[s],"/",medicines_files[[med_files]]), readRDS)
medicines<-do.call(rbind,medicines)
#select only female 12-55 years old
medicines<-medicines[age_start_follow_up>=min_age_preg & age_start_follow_up<=max_age_preg]
#create char: number of characters for medicinal_product_atc_code
medicines[,char:=nchar(medicinal_product_atc_code)]
#remove rows where atc code<3 characters
medicines<-medicines[char>=3]
#remove char
medicines[,char:=NULL]
#create atc_code(truncted to the third level)
medicines[,truncated_atc_code:=substr(medicinal_product_atc_code,1,3)]
if(medicines[,.N]>0){
#aggregate counts over year and truncated atc code for each person
medicines<-medicines[,.N, by=c("person_id","year","age_start_follow_up","start_follow_up","op_end_date","truncated_atc_code")]
setnames(medicines,"N","counts_medicines")
no_records<-medicines[,lapply(.SD,sum), by=c("year","truncated_atc_code"), .SDcols="counts_medicines"]
no_women<-medicines[,lapply(.SD, function(x) length(unique(na.omit(x)))), by=c("year","truncated_atc_code"), .SDcols="person_id"]
setnames(no_women, "person_id", "no_users")
no_records_all<-medicines[,lapply(.SD,sum), by=c("year"), .SDcols="counts_medicines"]
no_women_all<-medicines[,lapply(.SD, function(x) length(unique(na.omit(x)))), by=c("year"), .SDcols="person_id"]
setnames(no_women_all, "person_id", "no_users")
#####
#py
####
medicines[,year_start:=year(start_follow_up)]
medicines[,year_end:=year(op_end_date)]
min_year<-min(medicines[,"year_start"])
max_year<-max(medicines[,"year_end"])
years_interval<-seq(min_year,max_year,by=1)
res_py<-vector(mode="list",length(years_interval))
for (z in 1:length(years_interval)){
res_py[[z]]<-as.data.table(person_time(x=years_interval,dt=medicines[!duplicated(person_id)],year_index = z))
}
res_py<-do.call(rbind,res_py)
View(res_py)
View(res_py)
View(res_py)
medicines<-lapply(paste0(medicines_pop, subpopulations_names[s],"/",medicines_files[[med_files]]), readRDS)
medicines<-do.call(rbind,medicines)
#select only female 12-55 years old
medicines<-medicines[age_start_follow_up>=min_age_preg & age_start_follow_up<=max_age_preg]
#create char: number of characters for medicinal_product_atc_code
medicines[,char:=nchar(medicinal_product_atc_code)]
#remove rows where atc code<3 characters
medicines<-medicines[char>=3]
#remove char
medicines[,char:=NULL]
#create atc_code(truncted to the third level)
medicines[,truncated_atc_code:=substr(medicinal_product_atc_code,1,3)]
#aggregate counts over year and truncated atc code for each person
medicines<-medicines[,.N, by=c("person_id","year","age_start_follow_up","start_follow_up","op_end_date","truncated_atc_code")]
setnames(medicines,"N","counts_medicines")
no_records<-medicines[,lapply(.SD,sum), by=c("year","truncated_atc_code"), .SDcols="counts_medicines"]
no_women<-medicines[,lapply(.SD, function(x) length(unique(na.omit(x)))), by=c("year","truncated_atc_code"), .SDcols="person_id"]
setnames(no_women, "person_id", "no_users")
no_records_all<-medicines[,lapply(.SD,sum), by=c("year"), .SDcols="counts_medicines"]
no_women_all<-medicines[,lapply(.SD, function(x) length(unique(na.omit(x)))), by=c("year"), .SDcols="person_id"]
setnames(no_women_all, "person_id", "no_users")
#####
#py
####
medicines[,year_start:=year(start_follow_up)]
medicines[,year_end:=year(op_end_date)]
min_year<-min(medicines[,"year_start"])
max_year<-max(medicines[,"year_end"])
years_interval<-seq(min_year,max_year,by=1)
res_py<-vector(mode="list",length(years_interval))
for (z in 1:length(years_interval)){
res_py[[z]]<-as.data.table(person_time(x=years_interval,dt=medicines[!duplicated(person_id)],year_index = z))
}
res_py<-do.call(rbind,res_py)
res_py[,year:=as.numeric(year)]
View(res_py)
medicines[!duplicated(person_id)]
detach("package:e1071", unload = TRUE)
detach("package:dplyr", unload = TRUE)
detach("package:DT", unload = TRUE)
detach("package:dtplyr", unload = TRUE)
detach("package:magrittr", unload = TRUE)
detach("package:RcppAlgos", unload = TRUE)
detach("package:reshape2", unload = TRUE)
Output_file2<-CountPersonTime(
Dataset = medicines[!duplicated(person_id)],
Person_id = "person_id",
Start_study_time = "19900101",
End_study_time = "20211231",
Start_date = "start_follow_up",
End_date = "op_end_date",
Birth_date = "birth_date",
Increment="year",
Unit_of_age = "year",
include_remaning_ages = T,
Aggregate = T
)
medicines<-lapply(paste0(medicines_pop, subpopulations_names[s],"/",medicines_files[[med_files]]), readRDS)
medicines<-do.call(rbind,medicines)
#select only female 12-55 years old
medicines<-medicines[age_start_follow_up>=min_age_preg & age_start_follow_up<=max_age_preg]
#create char: number of characters for medicinal_product_atc_code
medicines[,char:=nchar(medicinal_product_atc_code)]
#remove rows where atc code<3 characters
medicines<-medicines[char>=3]
#remove char
medicines[,char:=NULL]
#create atc_code(truncted to the third level)
medicines[,truncated_atc_code:=substr(medicinal_product_atc_code,1,3)]
Output_file2<-CountPersonTime(
Dataset = medicines[!duplicated(person_id)],
Person_id = "person_id",
Start_study_time = "19900101",
End_study_time = "20211231",
Start_date = "start_follow_up",
End_date = "op_end_date",
Birth_date = "birth_date",
Increment="year",
Unit_of_age = "year",
include_remaning_ages = T,
Aggregate = T
)
View(Output_file2)
version
detach("package:ggplot2", unload = TRUE)
detach("package:lubridate", unload = TRUE)
>>>>>>> Stashed changes
